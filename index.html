<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>MatveyType</title>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
<link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600&family=Roboto+Mono:wght@400;700&display=swap" rel="stylesheet">
<style>
    :root{
        --bg-primary:#0a0a0a;
        --card: rgba(18,18,25,0.88);
        --text: #eef2ff;
        --muted: #9aa0a6;
        --accent: #8a5cf5;
        --correct: #4ade80;
        --incorrect: #f87171;
    }
    *{box-sizing:border-box;margin:0;padding:0}
    html,body{height:100%}
    body{
        font-family:'Poppins',system-ui,-apple-system,"Segoe UI",Roboto,Arial;
        background: linear-gradient(180deg,#071021 0%, #0b0a12 100%);
        color:var(--text);
        -webkit-font-smoothing:antialiased;
        -moz-osx-font-smoothing:grayscale;
        min-height:100vh;
        overflow:hidden;
    }

    /* Parallax */
    .parallax-container{position:fixed;inset:0;z-index:-4;overflow:hidden;pointer-events:none}
    .parallax-layer{position:absolute;width:120%;height:120%;background-position:center;background-repeat:no-repeat;background-size:cover;transition:transform 0.12s linear}
    .layer-1{ background: linear-gradient(180deg, #0a0a0a 0%, #1a1a2e 50%, #16213e 100%); }
    .layer-2{ background-image: radial-gradient(circle at 20% 80%, rgba(74,74,104,0.12) 0%, transparent 40%), radial-gradient(circle at 80% 20%, rgba(104,74,104,0.12) 0%, transparent 40%); filter: blur(2px); }
    .layer-3{ background-image: url("data:image/svg+xml,%3Csvg width='120' height='120' viewBox='0 0 120 120' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M11 18c3.866 0 7-3.134 7-7s-3.134-7-7-7-7 3.134-7 7 3.134 7 7 7zm48 25c3.866 0 7-3.134 7-7s-3.134-7-7-7-7 3.134-7 7 3.134 7 7 7zm-43-7c1.657 0 3-1.343 3-3s-1.343-3-3-3-3 1.343-3 3 1.343 3 3 3zm63 31c1.657 0 3-1.343 3-3s-1.343-3-3-3-3 1.343-3 3 1.343 3 3 3zM34 90c1.657 0 3-1.343 3-3s-1.343-3-3-3-3 1.343-3 3 1.343 3 3 3zm56-76c1.657 0 3-1.343 3-3s-1.343-3-3-3-3 1.343-3 3 1.343 3 3 3zM12 86c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm28-65c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4z' fill='%238a5cf5' fill-opacity='0.06' fill-rule='evenodd'/%3E%3C/svg%3E"); opacity:0.4; }

    /* New layer: small circles (size similar to snowflakes) */
    .layer-4{
        background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='200' height='200' viewBox='0 0 200 200'%3E%3Ccircle cx='10' cy='20' r='3' fill='%23ffffff' fill-opacity='0.06'/%3E%3Ccircle cx='40' cy='50' r='4' fill='%23ffffff' fill-opacity='0.06'/%3E%3Ccircle cx='80' cy='30' r='5' fill='%23ffffff' fill-opacity='0.06'/%3E%3Ccircle cx='120' cy='70' r='3' fill='%23ffffff' fill-opacity='0.06'/%3E%3Ccircle cx='160' cy='20' r='4' fill='%23ffffff' fill-opacity='0.06'/%3E%3Ccircle cx='30' cy='110' r='5' fill='%23ffffff' fill-opacity='0.06'/%3E%3Ccircle cx='70' cy='150' r='3' fill='%23ffffff' fill-opacity='0.06'/%3E%3Ccircle cx='110' cy='130' r='4' fill='%23ffffff' fill-opacity='0.06'/%3E%3Ccircle cx='150' cy='160' r='5' fill='%23ffffff' fill-opacity='0.06'/%3E%3Ccircle cx='190' cy='90' r='3' fill='%23ffffff' fill-opacity='0.06'/%3E%3C/svg%3E");
        opacity:0.45;
        filter: blur(1px);
        background-size: 300px 300px;
    }

    /* Snow */
    #snow-container{position:fixed;inset:0;pointer-events:none;z-index:-2}
    .snowflake{position:absolute;background:rgba(255,255,255,0.9);border-radius:50%;opacity:0.8;filter:blur(0.6px);animation-name:fall;animation-timing-function:linear;animation-iteration-count:infinite}
    @keyframes fall{0%{transform:translateY(-120px) rotate(0deg);opacity:0}10%{opacity:0.8}90%{opacity:0.6}100%{transform:translateY(100vh) rotate(360deg);opacity:0}}

    /* Garland */
    .garland{position:fixed;left:0;right:0;top:6px;height:36px;z-index:150;pointer-events:none;display:flex;align-items:center;justify-content:center}
    .garland .string{width:90%;height:2px;background:linear-gradient(90deg,#8a5cf5,#f59e0b);opacity:0.15;border-radius:4px}
    .garland .bulb{position:absolute;width:10px;height:10px;border-radius:50%;box-shadow:0 0 8px rgba(255,255,255,0.08);animation:blinkBulb 2s infinite}
    @keyframes blinkBulb{0%{opacity:0.4}50%{opacity:1}100%{opacity:0.4}}

    /* Center panel */
    .center-panel{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);width:calc(100% - 48px);max-width:1100px;z-index:2;display:flex;flex-direction:column;gap:14px;align-items:stretch;pointer-events:auto}
    .header{display:flex;justify-content:space-between;align-items:center;padding:14px;background:rgba(17,17,17,0.6);border-radius:12px;border:1px solid rgba(255,255,255,0.03);backdrop-filter:blur(8px)}
    .branding{display:flex;align-items:center;gap:12px;font-family:'Poppins',sans-serif;font-size:1.2rem;color:var(--text)}
    .controls{display:flex;gap:8px;align-items:center}
    .stat{background:var(--card);padding:8px 12px;border-radius:10px;border:1px solid rgba(255,255,255,0.03);color:var(--muted);font-size:0.92rem}

    .trainer{background:var(--card);padding:20px;border-radius:14px;border:1px solid rgba(255,255,255,0.04);box-shadow:0 14px 40px rgba(0,0,0,0.6)}

    /* Words area */
    .words-area{width:100%;height:170px;overflow:hidden;position:relative;padding:12px 18px;border-radius:10px;background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.005))}
    .words{font-family:'Roboto Mono', monospace;font-size:34px;line-height:1.12;color:var(--muted);word-break:normal;white-space:normal;display:block;will-change:transform}
    .word{display:inline-block;margin-right:18px;padding:4px 2px;border-radius:6px;vertical-align:bottom}
    .word.current{background:rgba(138,92,245,0.06);border-radius:6px}
    .word.correct{color:var(--correct)}
    .word.incorrect{color:var(--incorrect)}
    .char{display:inline-block}
    .char.typed-correct{color:var(--correct)}
    .char.typed-incorrect{color:var(--incorrect)}

    /* Caret: smooth transition between positions */
    .caret{position:absolute;width:2px;background:var(--text);z-index:6;pointer-events:none;border-radius:1px;display:none;opacity:1;transition:left 160ms cubic-bezier(.2,.9,.3,1), top 160ms cubic-bezier(.2,.9,.3,1)}
    /* no blink */

    .input-row{display:flex;gap:12px;align-items:center;justify-content:center;margin-top:10px}
    /* hide the browser caret inside the typing input (user requested) */
    #typingInput{width:70%;padding:12px 14px;border-radius:10px;background:transparent;border:1px solid rgba(255,255,255,0.04);color:var(--text);font-family:'Roboto Mono',monospace;font-size:18px;outline:none;caret-color: transparent;}
    #typingInput:focus{box-shadow:0 6px 20px rgba(138,92,245,0.12);border-color:var(--accent)}

    .bottom{display:flex;justify-content:space-between;align-items:center;gap:12px;flex-wrap:wrap;margin-top:12px}
    .btn{padding:8px 12px;border-radius:8px;background:rgba(255,255,255,0.02);border:1px solid rgba(255,255,255,0.03);color:var(--text);cursor:pointer}
    .btn.primary{background:var(--accent);border-color:var(--accent);color:#fff}
    .btn.ghost{background:transparent;border-color:rgba(255,255,255,0.04);color:var(--muted)}

    .controls-float{position:fixed;right:20px;bottom:18px;display:flex;flex-direction:column;gap:10px;z-index:101}
    .control-btn{width:46px;height:46px;border-radius:50%;background:rgba(26,26,26,0.9);border:1px solid rgba(255,255,255,0.04);color:var(--text);display:flex;align-items:center;justify-content:center;cursor:pointer}
    .control-btn.active{background:var(--accent);color:#fff}

    /* settings panel (caret) */
    .settings-panel{
        position:fixed;right:78px;bottom:18px;background:rgba(17,17,17,0.95);border-radius:10px;padding:12px;border:1px solid rgba(255,255,255,0.04);z-index:120;color:var(--muted);width:240px;box-shadow:0 8px 30px rgba(0,0,0,0.6)
    }
    .settings-panel label{display:flex;align-items:center;justify-content:space-between;font-size:0.9rem;margin-bottom:8px;color:var(--text)}
    .settings-panel input[type="range"]{width:100%}

    /* shop skins UI */
    .skin-item{display:flex;align-items:center;justify-content:space-between;padding:8px 10px;border-radius:8px;background:rgba(255,255,255,0.02);margin-top:8px;border:1px solid rgba(255,255,255,0.03)}
    .skin-preview{width:28px;height:28px;border-radius:2px;display:inline-block;margin-right:10px;vertical-align:middle;box-shadow:0 2px 6px rgba(0,0,0,0.35)}
    .skin-meta{flex:1;margin-right:8px}

    /* records modal */
    .modal-wide{background:linear-gradient(180deg, rgba(17,17,24,0.96), rgba(10,10,15,0.96));padding:18px;border-radius:12px;width:90%;max-width:720px;border:1px solid rgba(255,255,255,0.03);color:var(--text)}
    .records-list{display:flex;gap:12px;flex-wrap:wrap;justify-content:center}
    .record-item{background:rgba(255,255,255,0.02);padding:10px 14px;border-radius:8px;border:1px solid rgba(255,255,255,0.03);min-width:120px;text-align:center}

    /* candy bag bottom-left - changed to red */
    .candy-bag{position:fixed;left:18px;bottom:18px;z-index:120;display:flex;flex-direction:column;align-items:center;gap:6px;cursor:pointer}
    .bag-icon{width:64px;height:64px;background:linear-gradient(180deg,#ff4d4d 0%,#c40000 100%);border-radius:18px;display:flex;align-items:center;justify-content:center;font-size:28px;color:#fff;box-shadow:0 10px 30px rgba(0,0,0,0.5)}
    .candy-count{background:rgba(0,0,0,0.4);padding:6px 10px;border-radius:12px;color:var(--text);font-weight:600}

    /* overlay */
    .overlay{position:fixed;left:0;top:0;right:0;bottom:0;background:rgba(0,0,0,0.6);display:flex;align-items:center;justify-content:center;z-index:200}
    .modal{background:linear-gradient(180deg, rgba(17,17,24,0.96), rgba(10,10,15,0.96));padding:22px;border-radius:12px;width:94%;max-width:520px;border:1px solid rgba(255,255,255,0.03);text-align:center}
    .modal h2{font-family:'Poppins',sans-serif;color:var(--accent);margin-bottom:6px}
    .modal .big{font-family:'Poppins',sans-serif;font-size:36px;color:var(--text);margin-bottom:6px}
    .modal .meta{color:var(--muted);margin-bottom:12px}

    /* Responsive tweaks */
    @media(max-width:820px){.words-area{height:140px}.words{font-size:26px}}
    @media(max-width:480px){.words{font-size:20px}#typingInput{width:100%}.center-panel{width:calc(100% - 20px)}}

    /* Light theme */
    body.light-theme{--card: rgba(255,255,255,0.95);--text:#111827;--muted:#6b7280}
    body.light-theme .parallax-layer.layer-1{ background: linear-gradient(180deg,#f5f7fb 0%, #e3f2fd 50%, #bbdefb 100%); }
</style>
</head>
<body>
    <div class="parallax-container" aria-hidden="true">
        <div class="parallax-layer layer-1"></div>
        <div class="parallax-layer layer-2"></div>
        <div class="parallax-layer layer-3"></div>
        <div class="parallax-layer layer-4"></div>
    </div>

    <div id="snow-container" aria-hidden="true"></div>

    <div class="garland" aria-hidden="true">
        <div class="string"></div>
        <div class="bulb" style="left:10%;background:#ff4d4d"></div>
        <div class="bulb" style="left:22%;background:#ffd54d;animation-delay:0.3s"></div>
        <div class="bulb" style="left:34%;background:#6dd3ff;animation-delay:0.6s"></div>
        <div class="bulb" style="left:46%;background:#9b72f7;animation-delay:0.9s"></div>
        <div class="bulb" style="left:58%;background:#ff4d4d;animation-delay:1.2s"></div>
        <div class="bulb" style="left:70%;background:#ffd54d;animation-delay:1.5s"></div>
        <div class="bulb" style="left:82%;background:#6dd3ff;animation-delay:1.8s"></div>
    </div>

    <div class="center-panel" role="application" aria-label="MatveyType">
        <header class="header" role="banner">
            <div class="branding"><i class="fas fa-keyboard"></i>&nbsp;<strong>MatveyType</strong></div>
            <div class="controls" aria-hidden="false">
                <div class="stat">Таймер: <strong id="timer">60</strong>s</div>
                <button class="btn" id="openRecords"><i class="fas fa-trophy"></i>&nbsp;Рекорды</button>
            </div>
        </header>

        <main class="trainer" role="main">
            <div class="words-area" id="wordsArea" aria-live="polite" aria-atomic="false">
                <div class="words" id="words"></div>
                <div class="caret" id="caret" aria-hidden="true"></div>
            </div>

            <div class="input-row">
                <input id="typingInput" placeholder="Начните печатать для старта..." autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" />
            </div>

            <div class="bottom">
                <div style="display:flex;gap:8px;align-items:center">
                    <button class="btn ghost" id="langRu">Русский</button>
                    <button class="btn ghost" id="langEn">English</button>
                    <button class="btn" id="undoBtn" title="Назад к предыдущему слову (Backspace когда поле пустое)"><i class="fas fa-undo"></i></button>
                </div>

                <div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap">
                    <button class="btn" data-time="15">15s</button>
                    <button class="btn" data-time="30">30s</button>
                    <button class="btn primary" data-time="60" id="time60">60s</button>
                    <button class="btn" data-time="90">90s</button>
                    <button class="btn" id="restartBtn"><i class="fas fa-redo"></i>&nbsp;Начать заново <span style="opacity:0.8;margin-left:6px">Tab</span></button>
                </div>
            </div>
        </main>
    </div>

    <div class="controls-float" role="toolbar" aria-label="Controls">
        <button class="control-btn active" id="toggleSnow" title="Включить/выключить снег"><i class="fas fa-snowflake"></i></button>
        <button class="control-btn active" id="toggleParallax" title="Включить/выключить параллакс"><i class="fas fa-layer-group"></i></button>
        <button class="control-btn" id="toggleTheme" title="Сменить тему"><i class="fas fa-moon"></i></button>
        <button class="control-btn" id="openSettings" title="Настройки Caret"><i class="fas fa-cog"></i></button>
    </div>

    <!-- caret settings panel -->
    <div id="caretSettings" class="settings-panel" style="display:none" aria-hidden="true">
        <label>
            <span>Показывать caret</span>
            <input type="checkbox" id="showCaretCheckbox" />
        </label>
        <label style="margin-top:8px">
            <span>Отступ caret: <span id="caretOffsetLabel">0</span>px</span>
        </label>
        <input type="range" id="caretOffsetRange" min="-24" max="0" value="0" />
    </div>

    <!-- candy bag -->
    <div class="candy-bag" id="candyBag" title="Мешок конфет (клик — магазин)">
        <div class="bag-icon"><i class="fas fa-gift"></i></div>
        <div class="candy-count" id="candyCount">0</div>
    </div>

    <!-- shop modal -->
    <div id="shopOverlay" class="overlay" style="display:none" aria-hidden="true">
        <div class="modal-wide">
            <h2>Магазин конфет</h2>
            <div class="small">Конфет в мешке: <strong id="shopCandyCount">0</strong></div>

            <div style="margin-top:12px">
                <div>Ферма конфет</div>
                <div class="small" id="farmInfo">Уровень: 0 — 0 конфет/10мин</div>
                <div class="shop-row">
                    <div>
                        <button class="btn primary" id="buyFarmBtn">Купить / Апгрейд</button>
                    </div>
                    <div class="small">Стоимость апгрейда: <strong id="nextFarmCost">20</strong> конфет</div>
                </div>
                <div style="margin-top:8px" class="shop-row">
                    <div>
                        <button class="btn" id="claimBtn">Собрать накопленные</button>
                    </div>
                    <div class="small">Накоплено: <strong id="claimable">0</strong></div>
                </div>

                <hr style="opacity:0.05;margin:12px 0">

                <div><strong>Скины для caret</strong></div>
                <!-- Skin list -->
                <div id="skinsList">
                    <!-- Filled by JS -->
                </div>

            </div>
            <div style="display:flex;justify-content:center;gap:10px;margin-top:14px">
                <button class="btn primary" id="closeShopBtn">Закрыть</button>
            </div>
        </div>
    </div>

    <!-- records modal -->
    <div id="recordsOverlay" class="overlay" style="display:none" aria-hidden="true">
        <div class="modal-wide">
            <h2>Рекорды по времени</h2>
            <div class="records-list" id="recordsList"></div>
            <div style="display:flex;justify-content:center;gap:10px;margin-top:14px">
                <button class="btn primary" id="closeRecordsBtn">Закрыть</button>
            </div>
        </div>
    </div>

    <div id="resultsOverlay" class="overlay" style="display:none" aria-hidden="true">
        <div class="modal" role="dialog" aria-modal="true">
            <h2>Результаты</h2>
            <div class="big" id="resultWpm">0 WPM</div>
            <div class="meta" id="resultMeta">Точность: 100% • Символов: 0</div>
            <div style="display:flex;gap:10px;justify-content:center">
                <button class="btn primary" id="retryBtn">Повторить</button>
                <button class="btn ghost" id="closeResultsBtn">Закрыть</button>
            </div>
        </div>
    </div>

<script>
/* ========= Data & localStorage keys ========= */
const STORAGE = {
    language: 'mt_language',
    time: 'mt_time',
    showCaret: 'mt_showCaret',
    caretOffset: 'mt_caretOffset',
    caretSkinSelected: 'mt_caretSkinSelected',
    caretSkinsOwned: 'mt_caretSkinsOwned',
    snow: 'mt_snow',
    parallax: 'mt_parallax',
    theme: 'mt_theme',
    candies: 'mt_candies',
    farm: 'mt_farm',
    records: 'mt_records'
};

/* Word lists */
const wordLists = {
    ru: [ "это","быть","что","он","на","с","а","в","не","по","но","они","мы","как","из","у","к","за","год","от","так","же","ты","о","до","или","все","еще","нужно","можно","только","очень","свой","который","человек","время","дело","жизнь","день","рука","слово","место","лицо","друг","глаз","голова","дом","мир","случай","сторона","вода","конец","город","земля","система","часть","работа","вопрос","народ","число","раз","вид","развитие","тело","утро","путь","машина","дверь","образ","страна","солнце","комната","площадь","внимание","дорога","помощь","начало","мнение","состояние","шаг","бумага","неделя","голос","расстояние","мать","лето","вечер","картина","театр","информация","положение","центр","ответ","автор","стена","интерес","правило","ветер","цвет","причина","основа","культура","данные","момент" ],
    en: [ "the","be","to","of","and","a","in","that","have","I","it","for","not","on","with","he","as","you","do","at","this","but","his","by","from","they","we","say","her","she","or","an","will","my","one","all","would","there","their","what","so","up","out","if","about","who","get","which","go","me","when","make","can","like","time" ]
};

/* ========= DOM ========= */
const wordsEl = document.getElementById('words');
const wordsArea = document.getElementById('wordsArea');
const typingInput = document.getElementById('typingInput');
const caret = document.getElementById('caret');

const timerEl = document.getElementById('timer');

const toggleSnowBtn = document.getElementById('toggleSnow');
const toggleParallaxBtn = document.getElementById('toggleParallax');
const toggleThemeBtn = document.getElementById('toggleTheme');
const openSettingsBtn = document.getElementById('openSettings');

const settingsPanel = document.getElementById('caretSettings');
const showCaretCheckbox = document.getElementById('showCaretCheckbox');
const caretOffsetRange = document.getElementById('caretOffsetRange');
const caretOffsetLabel = document.getElementById('caretOffsetLabel');

const langRuBtn = document.getElementById('langRu');
const langEnBtn = document.getElementById('langEn');
const restartBtn = document.getElementById('restartBtn');
const timeButtons = document.querySelectorAll('[data-time]');
const undoBtn = document.getElementById('undoBtn');

const resultsOverlay = document.getElementById('resultsOverlay');
const resultWpm = document.getElementById('resultWpm');
const resultMeta = document.getElementById('resultMeta');
const retryBtn = document.getElementById('retryBtn');
const closeResultsBtn = document.getElementById('closeResultsBtn');

const candyBag = document.getElementById('candyBag');
const candyCountEl = document.getElementById('candyCount');

const shopOverlay = document.getElementById('shopOverlay');
const shopCandyCount = document.getElementById('shopCandyCount');
const farmInfo = document.getElementById('farmInfo');
const nextFarmCostEl = document.getElementById('nextFarmCost');
const buyFarmBtn = document.getElementById('buyFarmBtn');
const claimBtn = document.getElementById('claimBtn');
const claimableEl = document.getElementById('claimable');
const closeShopBtn = document.getElementById('closeShopBtn');
const skinsListEl = document.getElementById('skinsList');

const recordsOverlay = document.getElementById('recordsOverlay');
const recordsList = document.getElementById('recordsList');
const openRecordsBtn = document.getElementById('openRecords');
const closeRecordsBtn = document.getElementById('closeRecordsBtn');

/* ========= App state ========= */
let currentLanguage = localStorage.getItem(STORAGE.language) || 'ru';
let timeLimit = parseInt(localStorage.getItem(STORAGE.time)) || 60;
let timeLeft = timeLimit;
let timer = null;

let words = [];
let currentWordIndex = 0;

/* commit history for undo and per-word stats */
let wordStats = [];
let undoLock = false;

/* caret settings */
let showCaret = localStorage.getItem(STORAGE.showCaret) !== 'false';
let caretOffset = parseInt(localStorage.getItem(STORAGE.caretOffset)) || 0;
let caretSkinSelected = localStorage.getItem(STORAGE.caretSkinSelected) || 'default';
let caretSkinsOwned = JSON.parse(localStorage.getItem(STORAGE.caretSkinsOwned) || JSON.stringify({default:true, yellow:false, purple:false, candy:false}));

/* variables for line-based paging */
let visibleTranslateLines = 0;
let computedLineHeight = null;

/* typing counters (key-level) to count mistakes even if corrected) */
let totalKeystrokes = 0;      // printable keys typed during the test (excluding space)
let correctKeystrokes = 0;    // keystrokes that matched target char at time of typing
let mistakeKeystrokes = 0;    // keystrokes that didn't match target char at time of typing
let startTime = null;         // Date.now() when typing started

/* candies and farm */
function getCandies(){ return parseInt(localStorage.getItem(STORAGE.candies) || '0'); }
function setCandies(v){ localStorage.setItem(STORAGE.candies, String(Math.max(0, Math.floor(v)))); updateCandyUI(); }
function updateCandyUI(){ candyCountEl.textContent = getCandies(); shopCandyCount.textContent = getCandies(); }

function getFarm(){
    return JSON.parse(localStorage.getItem(STORAGE.farm) || JSON.stringify({level:0,lastClaim:Date.now()}));
}
function setFarm(f){ localStorage.setItem(STORAGE.farm, JSON.stringify(f)); updateFarmUI(); }

/* records */
function getRecords(){ return JSON.parse(localStorage.getItem(STORAGE.records) || '{}'); }
function setRecordForTime(t, wpm){ const r = getRecords(); r[String(t)] = wpm; localStorage.setItem(STORAGE.records, JSON.stringify(r)); }

/* ========= Helpers ========= */
/* randWords: avoid immediate duplicates (no same word twice in a row).
   If avoidPrev is provided, ensure first generated word != avoidPrev.
*/
function randWords(count = 300, avoidPrev = null){
    const pool = wordLists[currentLanguage] || wordLists.en;
    const poolLen = pool.length;
    const arr = [];
    let last = avoidPrev !== null ? String(avoidPrev) : null;

    for(let i = 0; i < count; i++){
        if(poolLen === 0) break;
        let candidate;
        let attempts = 0;
        do {
            candidate = pool[Math.floor(Math.random() * poolLen)];
            attempts++;
            if(attempts > 50) break;
        } while(candidate === last);
        arr.push(candidate);
        last = candidate;
    }
    return arr;
}

/* Compute lines based on offsetTop grouping */
function computeLines(){
    const children = Array.from(wordsEl.children);
    const lines = [];
    const tops = [];
    children.forEach(ch => {
        const t = ch.offsetTop;
        let foundIdx = tops.findIndex(v => Math.abs(v - t) < 2);
        if(foundIdx === -1){
            tops.push(t);
            foundIdx = tops.length - 1;
        }
        if(!lines[foundIdx]) lines[foundIdx] = [];
        lines[foundIdx].push(ch);
    });
    const sorted = lines
        .map((arr, idx) => ({top: tops[idx], arr}))
        .sort((a,b) => a.top - b.top)
        .map(x => x.arr);
    return sorted;
}

/* Set wordsArea height so exactly 3 visible lines (padding included) */
function adjustWordsAreaHeight(){
    const lines = computeLines();
    if(lines.length >= 2){
        const top0 = lines[0][0].offsetTop;
        const top1 = lines[1][0].offsetTop;
        computedLineHeight = top1 - top0;
    } else {
        const cs = window.getComputedStyle(wordsEl);
        const lh = cs.lineHeight;
        computedLineHeight = (lh && lh !== 'normal') ? parseFloat(lh) : (34 * 1.12);
    }
    const paddingVert = 24;
    wordsArea.style.height = Math.round(computedLineHeight * 3 + paddingVert) + 'px';
}

/* sync view to keep current word on the second (middle) visible line */
function syncViewToKeepCurrentOnSecondLine(){
    const lines = computeLines();
    let curLineIndex = -1;
    for(let i=0;i<lines.length;i++){
        if(lines[i].some(el => Number(el.dataset.index) === currentWordIndex)){
            curLineIndex = i;
            break;
        }
    }
    if(curLineIndex === -1) return;
    const desiredShift = Math.max(0, curLineIndex - 1);
    if(desiredShift !== visibleTranslateLines){
        visibleTranslateLines = desiredShift;
        const y = visibleTranslateLines * computedLineHeight;
        // instant jump is desired for lines; caret will move smoothly by CSS transition
        wordsEl.style.transition = 'none';
        wordsEl.style.transform = `translateY(-${y}px)`;
        void wordsEl.offsetWidth;
        wordsEl.style.transition = '';
    }
}

/* Rendering words (multi-line) */
function renderWords(){
    wordsEl.innerHTML = '';
    for(let i=0;i<words.length;i++){
        const w = words[i];
        const ws = document.createElement('span');
        ws.className = 'word';
        ws.dataset.index = i;
        for(let j=0;j<w.length;j++){
            const ch = document.createElement('span');
            ch.className = 'char';
            ch.dataset.charIndex = j;
            ch.textContent = w[j];
            ws.appendChild(ch);
        }
        wordsEl.appendChild(ws);
    }
    visibleTranslateLines = 0;
    wordsEl.style.transform = 'translateY(0px)';
    setTimeout(()=>{
        adjustWordsAreaHeight();
        markCurrentWord();
        positionCaret();
    }, 0);
}

/* Mark current word */
function markCurrentWord(){
    const prev = wordsEl.querySelector('.word.current');
    if(prev) prev.classList.remove('current');
    const cur = wordsEl.querySelector(`.word[data-index="${currentWordIndex}"]`);
    if(cur) cur.classList.add('current');
}

/* Apply caret skin (visual) */
function applyCaretSkin(){
    // caretSkinSelected: 'default' | 'yellow' | 'purple' | 'candy'
    let s = caretSkinSelected || 'default';
    // base properties
    caret.style.width = '2px';
    caret.style.background = 'var(--text)';
    caret.style.boxShadow = '';
    caret.style.borderRadius = '1px';

    if(s === 'yellow'){
        caret.style.background = '#ffd166';
        caret.style.boxShadow = '0 0 8px rgba(255,209,102,0.45)';
    } else if(s === 'purple'){
        caret.style.background = '#b18aff';
        caret.style.boxShadow = '0 0 10px rgba(177,138,255,0.35)';
    } else if(s === 'candy'){
        // striped red-white candy style using repeating linear gradient
        caret.style.width = '4px';
        caret.style.backgroundImage = 'repeating-linear-gradient(45deg, #fff 0 6px, #ff4d4d 6px 12px)';
        caret.style.boxShadow = '0 0 8px rgba(255,77,77,0.2)';
        caret.style.borderRadius = '4px';
    } else {
        // default
        caret.style.background = 'var(--text)';
    }
}

/* Position caret using getBoundingClientRect (accounts for transform)
   The caret has CSS transitions for smooth movement.
*/
function positionCaret(){
    const cur = wordsEl.querySelector(`.word[data-index="${currentWordIndex}"]`);
    if(!cur){ caret.style.display='none'; return; }
    const chars = cur.querySelectorAll('.char');
    const typed = typingInput.value || '';
    const pos = Math.min(Math.max(0, typed.length), chars.length);
    const containerRect = wordsArea.getBoundingClientRect();

    let caretX = 0;
    let caretY = 0;
    let caretH = Math.max(16, cur.getBoundingClientRect().height * 0.95);

    if(chars.length === 0){
        const curRect = cur.getBoundingClientRect();
        caretX = curRect.left - containerRect.left;
        caretY = curRect.top - containerRect.top;
    } else if(pos < chars.length){
        const targetChar = chars[pos];
        const charRect = targetChar.getBoundingClientRect();
        caretX = charRect.left - containerRect.left;
        caretY = charRect.top - containerRect.top;
        caretH = charRect.height;
    } else {
        const lastChar = chars[chars.length - 1];
        const charRect = lastChar.getBoundingClientRect();
        caretX = (charRect.left + charRect.width) - containerRect.left;
        caretY = charRect.top - containerRect.top;
        caretH = charRect.height;
    }

    const gap = caretOffset || 0;
    caret.style.left = (Math.round(caretX + gap)) + 'px';
    caret.style.top = (Math.round(caretY + 4)) + 'px';
    caret.style.height = (Math.round(caretH)) + 'px';
    caret.style.display = showCaret ? 'block' : 'none';
    caret.setAttribute('aria-hidden', showCaret ? 'false' : 'true');
}

/* Timer & Stats */
function setTimeButtonsDisabled(disabled){
    timeButtons.forEach(b=>{
        b.disabled = !!disabled;
        if(disabled){
            b.classList.add('ghost');
            b.style.cursor = 'not-allowed';
            b.setAttribute('aria-disabled', 'true');
        } else {
            b.classList.remove('ghost');
            b.style.cursor = '';
            b.removeAttribute('aria-disabled');
        }
    });
}

function startTimerIfNeeded(){
    if(timer) return;
    if(!typingInput.value) return;
    timeLeft = timeLimit;
    timerEl.textContent = timeLeft;
    if(!startTime) startTime = Date.now();
    timer = setInterval(()=>{
        timeLeft--;
        timerEl.textContent = timeLeft;
        if(timeLeft <= 0) finishTest();
    }, 1000);
    setTimeButtonsDisabled(true);
}

/* finishTest: use key-level counters and elapsed time to compute WPM & accuracy */
function finishTest(){
    clearInterval(timer);
    timer = null;
    typingInput.disabled = true;
    setTimeButtonsDisabled(false);

    // elapsed time in minutes
    const endTime = startTime ? Date.now() : Date.now();
    const elapsedMs = startTime ? (endTime - startTime) : (timeLimit * 1000);
    const elapsedMinutes = Math.max(elapsedMs / 60000, 1/60);

    const correct = correctKeystrokes;
    const total = totalKeystrokes;
    const acc = total > 0 ? Math.round((correct / total) * 100) : 100;
    const wpm = Math.round((correct / 5) / elapsedMinutes);

    // award candies
    const baseCandies = Math.max(1, Math.floor(wpm / 10));
    const records = getRecords();
    const prevRecord = records[String(timeLimit)] || 0;
    let bonus = 0;
    let isNewRecord = false;
    if(wpm > prevRecord){
        setRecordForTime(timeLimit, wpm);
        isNewRecord = true;
        bonus = 10;
    }
    const award = baseCandies + bonus;
    setCandies(getCandies() + award);

    // update results modal
    resultWpm.textContent = `${wpm} WPM`;
    resultMeta.textContent = `Точность: ${acc}% • Символов: ${correct}`;
    const awardText = `Награда: ${baseCandies}` + (isNewRecord ? ` + бонус за рекорд ${bonus} = ${award} конфет` : ` = ${award} конфет`);
    resultMeta.textContent += `\n${awardText}`;
    resultsOverlay.style.display = 'flex';
}

/* Commit word (on space or overflow) */
function commitCurrentWord(){
    const curWord = words[currentWordIndex];
    if(!curWord) return;
    const curEl = wordsEl.querySelector(`.word[data-index="${currentWordIndex}"]`);
    if(!curEl) return;
    const typedRaw = typingInput.value || '';
    const typed = typedRaw.trim();
    let matched = 0;
    const len = Math.min(typed.length, curWord.length);
    for(let i=0;i<len; i++){
        if(typed[i] === curWord[i]) matched++;
    }
    const incorrect = Math.max(0, curWord.length - matched);
    if(matched === curWord.length){
        curEl.classList.add('correct');
        curEl.querySelectorAll('.char').forEach(c=>{ c.classList.remove('typed-incorrect'); c.classList.add('typed-correct'); });
    } else {
        curEl.classList.add('incorrect');
        curEl.querySelectorAll('.char').forEach((c,idx)=>{
            c.classList.remove('typed-correct','typed-incorrect');
            if(idx < typed.length){
                if(typed[idx] === c.textContent) c.classList.add('typed-correct');
                else c.classList.add('typed-incorrect');
            }
        });
    }
    // store committed stats
    wordStats.push({typed, matched, incorrect, index: currentWordIndex});
    currentWordIndex++;
    typingInput.value = '';
    markCurrentWord();

    // append more words lazily, avoid repeating boundary word
    if(currentWordIndex > words.length - 60){
        const lastExisting = words[words.length - 1];
        const appended = randWords(150, lastExisting);
        appended.forEach(w=>words.push(w));
        for(let i=words.length-appended.length;i<words.length;i++){
            const w = words[i];
            const wspan = document.createElement('span');
            wspan.className='word';
            wspan.dataset.index = i;
            for(let j=0;j<w.length;j++){
                const ch = document.createElement('span');
                ch.className='char';
                ch.dataset.charIndex = j;
                ch.textContent = w[j];
                wspan.appendChild(ch);
            }
            wordsEl.appendChild(wspan);
        }
    }

    // After commit, sync view so the current word stays on the second visible line.
    setTimeout(()=> {
        adjustWordsAreaHeight();
        syncViewToKeepCurrentOnSecondLine();
        positionCaret();
    }, 0);
}

/* Undo previous committed word (single step) */
function goBackToPreviousWord(){
    if(currentWordIndex === 0) return;
    const last = wordStats.pop();
    if(!last) return;
    currentWordIndex = Math.max(0, last.index);
    const curEl = wordsEl.querySelector(`.word[data-index="${currentWordIndex}"]`);
    if(curEl){
        const chars = curEl.querySelectorAll('.char');
        const typed = last.typed || '';
        curEl.classList.remove('correct','incorrect');
        for(let i=0;i<chars.length;i++){
            const ch = chars[i];
            ch.classList.remove('typed-correct','typed-incorrect');
            if(i < typed.length){
                if(typed[i] === ch.textContent) ch.classList.add('typed-correct');
                else ch.classList.add('typed-incorrect');
            }
        }
    }
    typingInput.value = last.typed || '';
    markCurrentWord();
    setTimeout(()=>{
        adjustWordsAreaHeight();
        syncViewToKeepCurrentOnSecondLine();
        positionCaret();
    }, 0);
}

/* ========= Event handlers ========= */

/* Count printable keystrokes to compute WPM/accuracy across the entire typing period.
   We count characters on keydown (excluding control keys and space for speed/accuracy),
   mistakes are counted when the entered key doesn't match the target character at current position.
   Backspaces do NOT decrease mistake counts (we keep historical errors).
*/
typingInput.addEventListener('keydown', (e)=>{
    if(typingInput.disabled) return;

    // allow global Tab to work anywhere (handled separately)
    // undo on empty input
    if((e.key === 'Backspace' || e.key === 'Delete') && typingInput.value === ''){
        if(!undoLock){
            e.preventDefault();
            undoLock = true;
            goBackToPreviousWord();
        }
        return;
    }

    // Start timer on first real keydown
    if(!startTime && e.key && e.key.length === 1){
        startTime = Date.now();
    }

    // Count printable characters (excluding space)
    if(e.key && e.key.length === 1 && e.key !== ' '){
        totalKeystrokes++;
        const curWord = words[currentWordIndex] || '';
        const pos = typingInput.value.length; // position BEFORE key is applied
        if(pos < curWord.length && e.key === curWord[pos]){
            correctKeystrokes++;
        } else {
            mistakeKeystrokes++;
        }
    }

    // Ctrl+Backspace clears current visual typed state
    if(e.key === 'Backspace' && e.ctrlKey){
        e.preventDefault();
        typingInput.value = '';
        const curEl = wordsEl.querySelector(`.word[data-index="${currentWordIndex}"]`);
        if(curEl) curEl.querySelectorAll('.char').forEach(c=>c.classList.remove('typed-correct','typed-incorrect'));
        positionCaret();
    }

    // Enter/Tab handlers (typingInput-specific behaviour)
    if(e.key === 'Enter'){
        e.preventDefault();
        initTest();
        return;
    }
    if(e.key === 'Tab'){
        e.preventDefault();
        initTest();
        return;
    }
});
document.addEventListener('keyup', (e)=>{ if(e.key === 'Backspace' || e.key === 'Delete') undoLock = false; });

/* Typing input (visual per-char marking, caret, commit on space / overflow) */
typingInput.addEventListener('input', ()=>{
    // hide the placeholder after the first typing so it only shows at the very start
    if(typingInput.placeholder){
        typingInput.placeholder = '';
    }

    startTimerIfNeeded();
    const val = typingInput.value;
    const curWord = words[currentWordIndex];
    if(!curWord) return;
    const curEl = wordsEl.querySelector(`.word[data-index="${currentWordIndex}"]`);
    if(!curEl) return;
    const chars = curEl.querySelectorAll('.char');
    for(let i=0;i<chars.length;i++){
        const ch = chars[i];
        if(i < val.length){
            if(val[i] === ch.textContent){
                ch.classList.add('typed-correct'); ch.classList.remove('typed-incorrect');
            } else {
                ch.classList.add('typed-incorrect'); ch.classList.remove('typed-correct');
            }
        } else {
            ch.classList.remove('typed-correct','typed-incorrect');
        }
    }
    positionCaret();
    const endsWithSpace = val.endsWith(' ');
    if(endsWithSpace || val.length > curWord.length){
        commitCurrentWord();
    }
});

/* Global key handler: Tab should focus input and start a new test at any time (even after time ended/results shown)
   This addresses the bug: Tab only worked when input was active.
*/
document.addEventListener('keydown', (e)=>{
    if(e.key === 'Tab'){
        // If user is interacting with other controls, still we want Tab to bring focus and start test
        e.preventDefault();
        // If results overlay is visible, hide it and start new test
        if(resultsOverlay.style.display === 'flex' || resultsOverlay.style.display === 'block'){
            resultsOverlay.style.display = 'none';
        }
        initTest();
        typingInput.focus();
        return;
    }
});

/* Undo button */
undoBtn.addEventListener('click', ()=> goBackToPreviousWord());

/* focus typing on document click */
document.addEventListener('click', ()=>{ if(!typingInput.disabled) typingInput.focus(); });

restartBtn.addEventListener('click', initTest);

/* Language */
function setLanguage(lang){
    currentLanguage = lang;
    localStorage.setItem(STORAGE.language, lang);
    langRuBtn.classList.toggle('primary', lang === 'ru');
    langEnBtn.classList.toggle('primary', lang === 'en');
    initTest();
}
langRuBtn.addEventListener('click', ()=> setLanguage('ru'));
langEnBtn.addEventListener('click', ()=> setLanguage('en'));

/* Time buttons */
timeButtons.forEach(btn=>{
    btn.addEventListener('click', (e)=>{
        if(timer){
            btn.animate([{ transform: 'scale(1)' }, { transform: 'scale(0.96)' }, { transform: 'scale(1)' }], { duration: 220 });
            return;
        }
        const t = parseInt(btn.dataset.time);
        timeLimit = t;
        localStorage.setItem(STORAGE.time, String(t));
        timeButtons.forEach(b=>b.classList.remove('primary'));
        btn.classList.add('primary');
        timerEl.textContent = timeLimit;
    });
});

/* Parallax */
let parallaxEnabled = localStorage.getItem(STORAGE.parallax) !== 'false';
function initParallax(){
    const layers = document.querySelectorAll('.parallax-layer');
    let w = window.innerWidth, h = window.innerHeight;
    window.addEventListener('resize', ()=>{ w = window.innerWidth; h = window.innerHeight; });
    document.addEventListener('mousemove', (e)=>{
        if(!parallaxEnabled) return;
        const x = ((e.clientX/w)*100 - 50)/6;
        const y = ((e.clientY/h)*100 - 50)/6;
        layers.forEach((layer, idx)=>{
            const depth = idx + 1;
            layer.style.transform = `translate(${x*depth}px, ${y*depth}px)`;
        });
    });
}
function toggleParallax(){ parallaxEnabled = !parallaxEnabled; localStorage.setItem(STORAGE.parallax, parallaxEnabled ? 'true' : 'false'); toggleParallaxBtn.classList.toggle('active', parallaxEnabled); if(!parallaxEnabled) document.querySelectorAll('.parallax-layer').forEach(l=>l.style.transform='translate(0,0)'); }
toggleParallaxBtn.addEventListener('click', toggleParallax);

/* Snow */
let snowEnabled = localStorage.getItem(STORAGE.snow) !== 'false';
function createSnow(){
    const container = document.getElementById('snow-container');
    container.innerHTML = '';
    if(!snowEnabled){ container.style.display='none'; return; }
    const count = 90;
    for(let i=0;i<count;i++){
        const s = document.createElement('div');
        s.className='snowflake';
        const size = Math.random()*5 + 2;
        s.style.width = s.style.height = size + 'px';
        s.style.left = Math.random()*100 + 'vw';
        s.style.animationDuration = (Math.random()*10 + 8) + 's';
        s.style.animationDelay = (Math.random()*5) + 's';
        s.style.opacity = (Math.random()*0.6 + 0.2);
        container.appendChild(s);
    }
    container.style.display='block';
}
function toggleSnow(){ snowEnabled = !snowEnabled; localStorage.setItem(STORAGE.snow, snowEnabled ? 'true' : 'false'); toggleSnowBtn.classList.toggle('active', snowEnabled); createSnow(); }
toggleSnowBtn.addEventListener('click', toggleSnow);

/* Theme */
let lightTheme = localStorage.getItem(STORAGE.theme) === 'light';
function applyTheme(){ if(lightTheme){ document.body.classList.add('light-theme'); toggleThemeBtn.classList.add('active'); toggleThemeBtn.innerHTML='<i class="fas fa-sun"></i>'; } else { document.body.classList.remove('light-theme'); toggleThemeBtn.classList.remove('active'); toggleThemeBtn.innerHTML='<i class="fas fa-moon"></i>'; } localStorage.setItem(STORAGE.theme, lightTheme ? 'light' : 'dark'); }
toggleThemeBtn.addEventListener('click', ()=>{ lightTheme = !lightTheme; applyTheme(); });

/* Settings: caret */
openSettingsBtn.addEventListener('click', ()=>{
    settingsPanel.style.display = settingsPanel.style.display === 'none' ? 'block' : 'none';
    settingsPanel.setAttribute('aria-hidden', settingsPanel.style.display === 'none' ? 'true' : 'false');
});
showCaretCheckbox.checked = showCaret;
caretOffsetRange.value = caretOffset;
caretOffsetLabel.textContent = caretOffset;
showCaretCheckbox.addEventListener('change', (e)=>{
    showCaret = !!e.target.checked;
    localStorage.setItem(STORAGE.showCaret, showCaret ? 'true' : 'false');
    positionCaret();
});
caretOffsetRange.addEventListener('input', (e)=>{
    caretOffset = parseInt(e.target.value);
    caretOffsetLabel.textContent = caretOffset;
    localStorage.setItem(STORAGE.caretOffset, String(caretOffset));
    positionCaret();
});

/* ===== Candies, Farm, Shop & Skins ===== */
function getClaimable(){
    const farm = getFarm();
    const level = farm.level || 0;
    if(level <= 0) return 0;
    const rate = level;
    const interval = 10 * 60 * 1000;
    const now = Date.now();
    const elapsed = Math.max(0, now - (farm.lastClaim || now));
    return Math.floor(elapsed / interval) * rate;
}

function updateFarmUI(){
    const farm = getFarm();
    const level = farm.level || 0;
    const rate = level;
    farmInfo.textContent = `Уровень: ${level} — ${rate} конфет/10мин`;
    const nextCost = 20 + level * 5;
    nextFarmCostEl.textContent = nextCost;
    claimableEl.textContent = getClaimable();
    shopCandyCount.textContent = getCandies();
}

candyBag.addEventListener('click', ()=>{
    updateFarmUI();
    renderSkinsList();
    shopOverlay.style.display = 'flex';
});

closeShopBtn.addEventListener('click', ()=> shopOverlay.style.display = 'none');

buyFarmBtn.addEventListener('click', ()=>{
    const farm = getFarm();
    const level = farm.level || 0;
    const cost = 20 + level * 5;
    let candies = getCandies();
    if(candies < cost){ alert('Недостаточно конфет'); return; }
    candies -= cost;
    setCandies(candies);
    farm.level = level + 1;
    farm.lastClaim = Date.now();
    setFarm(farm);
    updateFarmUI();
});

claimBtn.addEventListener('click', ()=>{
    const farm = getFarm();
    const claimable = getClaimable();
    if(claimable <= 0){ alert('Нечего получать'); return; }
    setCandies(getCandies() + claimable);
    const interval = 10 * 60 * 1000;
    const now = Date.now();
    const consumedIntervals = Math.floor((now - (farm.lastClaim || now)) / interval);
    farm.lastClaim = (farm.lastClaim || now) + consumedIntervals * interval;
    setFarm(farm);
    updateFarmUI();
});

/* Skins: definitions */
const SKINS = [
    {id:'yellow', name:'Жёлтый', cost:10, previewStyle: 'background:#ffd166'},
    {id:'purple', name:'Фиолетовый', cost:50, previewStyle: 'background:#b18aff'},
    {id:'candy', name:'Леденец (7)', cost:100, previewStyle: 'background:repeating-linear-gradient(45deg,#fff 0 6px,#ff4d4d 6px 12px);'}
];

function saveSkinsOwned(){
    localStorage.setItem(STORAGE.caretSkinsOwned, JSON.stringify(caretSkinsOwned));
}
function saveSelectedSkin(){
    localStorage.setItem(STORAGE.caretSkinSelected, caretSkinSelected);
    applyCaretSkin();
}

/* Render skins list inside shop UI */
function renderSkinsList(){
    skinsListEl.innerHTML = '';
    SKINS.forEach(s=>{
        const item = document.createElement('div');
        item.className = 'skin-item';
        const preview = document.createElement('span');
        preview.className = 'skin-preview';
        preview.style.cssText = s.previewStyle;
        const meta = document.createElement('div');
        meta.className = 'skin-meta';
        meta.innerHTML = `<div style="font-weight:600">${s.name}</div><div class="small">Стоимость: ${s.cost} конфет</div>`;
        const actions = document.createElement('div');
        // ownership or buy/equip button logic
        const owned = !!caretSkinsOwned[s.id];
        if(!owned){
            const btn = document.createElement('button');
            btn.className='btn';
            btn.textContent = `Купить ${s.cost}`;
            btn.addEventListener('click', ()=>{
                buySkin(s.id, s.cost);
            });
            actions.appendChild(btn);
        } else {
            const equipBtn = document.createElement('button');
            equipBtn.className = 'btn';
            equipBtn.textContent = (caretSkinSelected === s.id) ? 'В экипе' : 'Экипировать';
            equipBtn.disabled = (caretSkinSelected === s.id);
            equipBtn.addEventListener('click', ()=>{
                caretSkinSelected = s.id;
                saveSelectedSkin();
                renderSkinsList();
            });
            actions.appendChild(equipBtn);
        }
        item.appendChild(preview);
        item.appendChild(meta);
        item.appendChild(actions);
        skinsListEl.appendChild(item);
    });

    // Add a "reset to default" control
    const reset = document.createElement('div');
    reset.style.marginTop = '10px';
    reset.innerHTML = `<button class="btn ghost" id="resetSkinBtn">Сбросить скин</button>`;
    skinsListEl.appendChild(reset);
    document.getElementById('resetSkinBtn').addEventListener('click', ()=>{
        caretSkinSelected = 'default';
        saveSelectedSkin();
        renderSkinsList();
    });
}

/* Buy skin */
function buySkin(id, cost){
    let candies = getCandies();
    if(candies < cost){ alert('Недостаточно конфет'); return; }
    candies -= cost;
    setCandies(candies);
    caretSkinsOwned[id] = true;
    saveSkinsOwned();
    // auto-equip after purchase
    caretSkinSelected = id;
    saveSelectedSkin();
    renderSkinsList();
}

/* Records modal */
openRecordsBtn.addEventListener('click', ()=>{
    const recs = getRecords();
    recordsList.innerHTML = '';
    [15,30,60,90].forEach(t=>{
        const item = document.createElement('div');
        item.className = 'record-item';
        const val = recs[String(t)] || 0;
        item.innerHTML = `<div><strong>${t}s</strong></div><div style="margin-top:6px">${val ? val + ' WPM' : '—'}</div>`;
        recordsList.appendChild(item);
    });
    recordsOverlay.style.display = 'flex';
});
closeRecordsBtn.addEventListener('click', ()=> recordsOverlay.style.display = 'none');

/* Results modal close/retry */
retryBtn.addEventListener('click', ()=>{ resultsOverlay.style.display='none'; initTest(); });
closeResultsBtn.addEventListener('click', ()=>{ resultsOverlay.style.display='none'; });

/* ========= Init / restart ========= */
function resetTypingCounters(){
    totalKeystrokes = 0;
    correctKeystrokes = 0;
    mistakeKeystrokes = 0;
    startTime = null;
}

function initTest(){
    clearInterval(timer);
    timer = null;
    setTimeButtonsDisabled(false);
    typingInput.disabled = false;
    typingInput.value = '';
    typingInput.placeholder = 'Начните печатать для старта...';
    typingInput.focus();
    currentWordIndex = 0;
    wordStats = [];
    timeLeft = timeLimit;
    timerEl.textContent = timeLimit;
    resultsOverlay.style.display = 'none';
    words = randWords(300, null);
    renderWords();
    caret.style.display = showCaret ? 'block' : 'none';
    updateCandyUI();
    updateFarmUI();
    resetTypingCounters();
    // apply skin (in case changed during shop)
    applyCaretSkin();
}

document.addEventListener('DOMContentLoaded', ()=>{
    // restore settings
    document.getElementById('langRu').classList.toggle('primary', currentLanguage === 'ru');
    document.getElementById('langEn').classList.toggle('primary', currentLanguage === 'en');
    document.querySelectorAll('[data-time]').forEach(b=>b.classList.toggle('primary', parseInt(b.dataset.time) === timeLimit));
    showCaretCheckbox.checked = showCaret;
    caretOffsetRange.value = caretOffset;
    caretOffsetLabel.textContent = caretOffset;

    // restore skins state
    caretSkinsOwned = JSON.parse(localStorage.getItem(STORAGE.caretSkinsOwned) || JSON.stringify(caretSkinsOwned));
    caretSkinSelected = localStorage.getItem(STORAGE.caretSkinSelected) || caretSkinSelected;

    createSnow();
    toggleSnowBtn.classList.toggle('active', snowEnabled);
    initParallax();
    toggleParallaxBtn.classList.toggle('active', parallaxEnabled);
    applyTheme();

    if(localStorage.getItem(STORAGE.candies) === null) localStorage.setItem(STORAGE.candies, '0');
    if(localStorage.getItem(STORAGE.farm) === null) localStorage.setItem(STORAGE.farm, JSON.stringify({level:0,lastClaim:Date.now()}));
    if(localStorage.getItem(STORAGE.records) === null) localStorage.setItem(STORAGE.records, JSON.stringify({}));

    updateCandyUI();
    updateFarmUI();

    initTest();
    applyCaretSkin();
    renderSkinsList();

    setInterval(()=>{ if(!snowEnabled) return; const flakes=document.querySelectorAll('.snowflake'); if(flakes.length){ const idx=Math.floor(Math.random()*flakes.length); const f=flakes[idx]; if(f) f.style.opacity = (Math.random()*0.6 + 0.2); } }, 1200);

    // Recompute layout on resize
    window.addEventListener('resize', () => {
        setTimeout(()=> {
            adjustWordsAreaHeight();
            syncViewToKeepCurrentOnSecondLine();
            positionCaret();
        }, 50);
    });
});
</script>
</body>
</html>